{"version":3,"file":"shared.js","mappings":"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","sources":["webpack://ishka-extension/./src/shared/state/index.ts","webpack://ishka-extension/./src/shared/utils/index.ts"],"sourcesContent":["import type { ExtensionState, DeepPartial } from '../types';\n\nexport class StateManager {\n  private state: ExtensionState;\n  private listeners: Map<string, Set<(state: ExtensionState) => void>>;\n  private storage: chrome.storage.LocalStorageArea | null;\n\n  constructor(initialState: ExtensionState) {\n    this.state = initialState;\n    this.listeners = new Map();\n    this.storage = typeof chrome !== 'undefined' && chrome.storage ? chrome.storage.local : null;\n    this.initializeStorage();\n  }\n\n  private async initializeStorage(): Promise<void> {\n    if (!this.storage) {\n      console.warn('Chrome storage API not available');\n      return;\n    }\n\n    try {\n      const stored = await this.storage.get(null);\n      if (stored && Object.keys(stored).length > 0) {\n        this.state = { ...this.state, ...stored };\n      }\n    } catch (error) {\n      console.warn('Failed to load state from storage:', error);\n    }\n  }\n\n  getState(): ExtensionState {\n    return { ...this.state };\n  }\n\n  async setState(partial: DeepPartial<ExtensionState>): Promise<void> {\n    const previousState = { ...this.state };\n    this.state = this.mergeState(this.state, partial);\n\n    // Save to storage\n    if (this.storage) {\n      try {\n        await this.storage.set(partial);\n      } catch (error) {\n        console.error('Failed to save state to storage:', error);\n      }\n    }\n\n    // Notify listeners\n    this.notifyListeners(previousState, this.state);\n  }\n\n  private mergeState(current: ExtensionState, partial: DeepPartial<ExtensionState>): ExtensionState {\n    const merged = { ...current };\n    \n    for (const [key, value] of Object.entries(partial)) {\n      if (value !== undefined) {\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n          merged[key as keyof ExtensionState] = this.mergeState(\n            current[key as keyof ExtensionState] as any,\n            value as any\n          ) as any;\n        } else {\n          merged[key as keyof ExtensionState] = value as any;\n        }\n      }\n    }\n    \n    return merged;\n  }\n\n  subscribe(key: string, callback: (state: ExtensionState) => void): () => void {\n    if (!this.listeners.has(key)) {\n      this.listeners.set(key, new Set());\n    }\n    \n    this.listeners.get(key)!.add(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const keyListeners = this.listeners.get(key);\n      if (keyListeners) {\n        keyListeners.delete(callback);\n        if (keyListeners.size === 0) {\n          this.listeners.delete(key);\n        }\n      }\n    };\n  }\n\n  private notifyListeners(previousState: ExtensionState, currentState: ExtensionState): void {\n    // Notify all listeners\n    for (const [key, listeners] of this.listeners) {\n      if (this.hasStateChanged(key, previousState, currentState)) {\n        listeners.forEach(callback => {\n          try {\n            callback(currentState);\n          } catch (error) {\n            console.error(`Error in state listener for key \"${key}\":`, error);\n          }\n        });\n      }\n    }\n  }\n\n  private hasStateChanged(key: string, previous: ExtensionState, current: ExtensionState): boolean {\n    const previousValue = this.getNestedValue(previous, key);\n    const currentValue = this.getNestedValue(current, key);\n    return JSON.stringify(previousValue) !== JSON.stringify(currentValue);\n  }\n\n  private getNestedValue(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => current?.[key], obj);\n  }\n\n  // Convenience methods for specific state updates\n  async updateUser(userUpdates: DeepPartial<ExtensionState['user']>): Promise<void> {\n    await this.setState({ user: userUpdates });\n  }\n\n  async updateConversations(conversationUpdates: DeepPartial<ExtensionState['conversations']>): Promise<void> {\n    await this.setState({ conversations: conversationUpdates });\n  }\n\n  async updateUI(uiUpdates: DeepPartial<ExtensionState['ui']>): Promise<void> {\n    await this.setState({ ui: uiUpdates });\n  }\n\n  async updateSettings(settingsUpdates: DeepPartial<ExtensionState['settings']>): Promise<void> {\n    await this.setState({ settings: settingsUpdates });\n  }\n\n  // Utility methods\n  async resetState(): Promise<void> {\n    const initialState = this.getInitialState();\n    await this.setState(initialState);\n  }\n\n  async clearStorage(): Promise<void> {\n    if (this.storage) {\n      try {\n        await this.storage.clear();\n      } catch (error) {\n        console.error('Failed to clear storage:', error);\n      }\n    }\n  }\n\n  private getInitialState(): ExtensionState {\n    return {\n      user: {\n        isPremium: false,\n        isLoggedIn: false,\n        preferences: {\n          theme: 'auto',\n          language: 'en',\n          enableNotifications: true,\n          autoSave: true,\n        },\n      },\n      conversations: {\n        conversations: [],\n        folders: [],\n        searchQuery: '',\n        isLoading: false,\n      },\n      ui: {\n        isModalOpen: false,\n        snackbar: {\n          isVisible: false,\n          message: '',\n          type: 'info',\n        },\n        sidebar: {\n          isOpen: false,\n          activeTab: 'conversations',\n        },\n        loading: {\n          isLoading: false,\n        },\n      },\n      settings: {\n        general: {\n          autoSaveInterval: 30000,\n          maxConversations: 100,\n          enableRTL: false,\n          enableVoiceDownload: false,\n        },\n        premium: {\n          isEnabled: false,\n          features: [],\n        },\n        advanced: {\n          debugMode: false,\n          enableLogging: false,\n        },\n      },\n    };\n  }\n}\n\n// Global state instance\nexport const stateManager = new StateManager({\n  user: {\n    isPremium: false,\n    isLoggedIn: false,\n    preferences: {\n      theme: 'auto',\n      language: 'en',\n      enableNotifications: true,\n      autoSave: true,\n    },\n  },\n  conversations: {\n    conversations: [],\n    folders: [],\n    searchQuery: '',\n    isLoading: false,\n  },\n  ui: {\n    isModalOpen: false,\n    snackbar: {\n      isVisible: false,\n      message: '',\n      type: 'info',\n    },\n    sidebar: {\n      isOpen: false,\n      activeTab: 'conversations',\n    },\n    loading: {\n      isLoading: false,\n    },\n  },\n  settings: {\n    general: {\n      autoSaveInterval: 30000,\n      maxConversations: 100,\n      enableRTL: false,\n      enableVoiceDownload: false,\n    },\n    premium: {\n      isEnabled: false,\n      features: [],\n    },\n    advanced: {\n      debugMode: false,\n      enableLogging: false,\n    },\n  },\n});\n\n// Export convenience functions\nexport const getState = () => stateManager.getState();\nexport const setState = (partial: DeepPartial<ExtensionState>) => stateManager.setState(partial);\nexport const subscribe = (key: string, callback: (state: ExtensionState) => void) => \n  stateManager.subscribe(key, callback);","// DOM Utilities\nexport const domUtils = {\n  /**\n   * Wait for an element to be present in the DOM\n   */\n  waitForElement(selector: string, timeout = 10000): Promise<Element> {\n    return new Promise((resolve, reject) => {\n      const element = document.querySelector(selector);\n      if (element) {\n        resolve(element);\n        return;\n      }\n\n      const observer = new MutationObserver(() => {\n        const element = document.querySelector(selector);\n        if (element) {\n          observer.disconnect();\n          resolve(element);\n        }\n      });\n\n      observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n      });\n\n      setTimeout(() => {\n        observer.disconnect();\n        reject(new Error(`Element ${selector} not found within ${timeout}ms`));\n      }, timeout);\n    });\n  },\n\n  /**\n   * Create and inject a script element\n   */\n  injectScript(src: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = () => resolve();\n      script.onerror = () => reject(new Error(`Failed to load script: ${src}`));\n      document.head.appendChild(script);\n    });\n  },\n\n  /**\n   * Create and inject a style element\n   */\n  injectStyle(css: string): void {\n    const style = document.createElement('style');\n    style.textContent = css;\n    document.head.appendChild(style);\n  },\n\n  /**\n   * Remove all elements matching a selector\n   */\n  removeElements(selector: string): void {\n    document.querySelectorAll(selector).forEach(el => el.remove());\n  },\n\n  /**\n   * Check if element is visible\n   */\n  isElementVisible(element: Element): boolean {\n    const style = window.getComputedStyle(element);\n    return style.display !== 'none' && style.visibility !== 'hidden' && (element as HTMLElement).offsetParent !== null;\n  },\n};\n\n// Storage Utilities\nexport const storageUtils = {\n  /**\n   * Get a value from Chrome storage\n   */\n  async get<T>(key: string): Promise<T | null> {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n      return null;\n    }\n\n    try {\n      const result = await chrome.storage.local.get(key);\n      return result[key] || null;\n    } catch (error) {\n      console.error('Failed to get from storage:', error);\n      return null;\n    }\n  },\n\n  /**\n   * Set a value in Chrome storage\n   */\n  async set(key: string, value: any): Promise<void> {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n      return;\n    }\n\n    try {\n      await chrome.storage.local.set({ [key]: value });\n    } catch (error) {\n      console.error('Failed to set in storage:', error);\n    }\n  },\n\n  /**\n   * Remove a value from Chrome storage\n   */\n  async remove(key: string): Promise<void> {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n      return;\n    }\n\n    try {\n      await chrome.storage.local.remove(key);\n    } catch (error) {\n      console.error('Failed to remove from storage:', error);\n    }\n  },\n\n  /**\n   * Clear all storage\n   */\n  async clear(): Promise<void> {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n      return;\n    }\n\n    try {\n      await chrome.storage.local.clear();\n    } catch (error) {\n      console.error('Failed to clear storage:', error);\n    }\n  },\n};\n\n// String Utilities\nexport const stringUtils = {\n  /**\n   * Generate a random ID\n   */\n  generateId(): string {\n    return Math.random().toString(36).substring(2) + Date.now().toString(36);\n  },\n\n  /**\n   * Truncate text to a specific length\n   */\n  truncate(text: string, maxLength: number, suffix = '...'): string {\n    if (text.length <= maxLength) return text;\n    return text.substring(0, maxLength - suffix.length) + suffix;\n  },\n\n  /**\n   * Convert text to title case\n   */\n  toTitleCase(text: string): string {\n    return text.replace(/\\w\\S*/g, (txt) => \n      txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()\n    );\n  },\n\n  /**\n   * Sanitize HTML string\n   */\n  sanitizeHtml(html: string): string {\n    const div = document.createElement('div');\n    div.textContent = html;\n    return div.innerHTML;\n  },\n};\n\n// Date Utilities\nexport const dateUtils = {\n  /**\n   * Format date to relative time\n   */\n  formatRelativeTime(date: Date): string {\n    const now = new Date();\n    const diff = now.getTime() - date.getTime();\n    const seconds = Math.floor(diff / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;\n    if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;\n    if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;\n    return 'Just now';\n  },\n\n  /**\n   * Format date to readable string\n   */\n  formatDate(date: Date): string {\n    return date.toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  },\n};\n\n// Validation Utilities\nexport const validationUtils = {\n  /**\n   * Check if string is a valid URL\n   */\n  isValidUrl(string: string): boolean {\n    try {\n      new URL(string);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check if string is a valid email\n   */\n  isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  },\n\n  /**\n   * Check if value is not null or undefined\n   */\n  isDefined<T>(value: T): value is NonNullable<T> {\n    return value !== null && value !== undefined;\n  },\n};\n\n// Event Utilities\nexport const eventUtils = {\n  /**\n   * Debounce function calls\n   */\n  debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait: number\n  ): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout;\n    return (...args: Parameters<T>) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func(...args), wait);\n    };\n  },\n\n  /**\n   * Throttle function calls\n   */\n  throttle<T extends (...args: any[]) => any>(\n    func: T,\n    limit: number\n  ): (...args: Parameters<T>) => void {\n    let inThrottle: boolean;\n    return (...args: Parameters<T>) => {\n      if (!inThrottle) {\n        func(...args);\n        inThrottle = true;\n        setTimeout(() => (inThrottle = false), limit);\n      }\n    };\n  },\n};\n\n// Export all utilities\nexport default {\n  dom: domUtils,\n  storage: storageUtils,\n  string: stringUtils,\n  date: dateUtils,\n  validation: validationUtils,\n  event: eventUtils,\n};"],"names":["stateManager","constructor","initialState","this","state","listeners","Map","storage","chrome","local","initializeStorage","stored","get","Object","keys","length","error","console","warn","getState","setState","partial","previousState","mergeState","set","notifyListeners","current","merged","key","value","entries","undefined","Array","isArray","subscribe","callback","has","Set","add","keyListeners","delete","size","currentState","hasStateChanged","forEach","previous","previousValue","getNestedValue","currentValue","JSON","stringify","obj","path","split","reduce","updateUser","userUpdates","user","updateConversations","conversationUpdates","conversations","updateUI","uiUpdates","ui","updateSettings","settingsUpdates","settings","resetState","getInitialState","clearStorage","clear","isPremium","isLoggedIn","preferences","theme","language","enableNotifications","autoSave","folders","searchQuery","isLoading","isModalOpen","snackbar","isVisible","message","type","sidebar","isOpen","activeTab","loading","general","autoSaveInterval","maxConversations","enableRTL","enableVoiceDownload","premium","isEnabled","features","advanced","debugMode","enableLogging","domUtils","waitForElement","selector","timeout","Promise","resolve","reject","element","document","querySelector","observer","MutationObserver","disconnect","observe","body","childList","subtree","setTimeout","Error","injectScript","src","script","createElement","onload","onerror","head","appendChild","injectStyle","css","style","textContent","removeElements","querySelectorAll","el","remove","isElementVisible","window","getComputedStyle","display","visibility","offsetParent","storageUtils"],"sourceRoot":""}