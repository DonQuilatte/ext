{"version":3,"file":"background.js","mappings":"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","sources":["webpack://ishka-extension/webpack/runtime/chunk loaded","webpack://ishka-extension/./src/shared/api/index.ts","webpack://ishka-extension/./src/background/index.ts","webpack://ishka-extension/webpack/bootstrap","webpack://ishka-extension/webpack/runtime/define property getters","webpack://ishka-extension/webpack/runtime/hasOwnProperty shorthand","webpack://ishka-extension/webpack/runtime/jsonp chunk loading","webpack://ishka-extension/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import type { APIClient, Conversation, Folder, Prompt } from '../types';\n\nexport class ChatGPTAPIClient implements APIClient {\n  private baseUrl = 'https://chatgpt.com';\n  private isAuthenticated = false;\n\n  constructor() {\n    this.checkAuthentication();\n  }\n\n  private async checkAuthentication(): Promise<void> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/auth/session`);\n      this.isAuthenticated = response.ok;\n    } catch (error) {\n      console.warn('Failed to check authentication:', error);\n      this.isAuthenticated = false;\n    }\n  }\n\n  private async makeRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${this.baseUrl}${endpoint}`;\n    \n    const defaultOptions: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      credentials: 'include',\n      ...options,\n    };\n\n    try {\n      const response = await fetch(url, defaultOptions);\n      \n      if (!response.ok) {\n        throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error(`API request failed for ${endpoint}:`, error);\n      throw error;\n    }\n  }\n\n  async getConversations(): Promise<Conversation[]> {\n    try {\n      const data = await this.makeRequest<{ items: any[] }>('/api/conversations');\n      return data.items.map(this.mapConversationFromAPI);\n    } catch (error) {\n      console.error('Failed to fetch conversations:', error);\n      return [];\n    }\n  }\n\n  async getConversation(id: string): Promise<Conversation> {\n    const data = await this.makeRequest<any>(`/api/conversations/${id}`);\n    return this.mapConversationFromAPI(data);\n  }\n\n  async createConversation(title: string): Promise<Conversation> {\n    const data = await this.makeRequest<any>('/api/conversations', {\n      method: 'POST',\n      body: JSON.stringify({ title }),\n    });\n    return this.mapConversationFromAPI(data);\n  }\n\n  async updateConversation(id: string, updates: Partial<Conversation>): Promise<Conversation> {\n    const data = await this.makeRequest<any>(`/api/conversations/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates),\n    });\n    return this.mapConversationFromAPI(data);\n  }\n\n  async deleteConversation(id: string): Promise<void> {\n    await this.makeRequest(`/api/conversations/${id}`, {\n      method: 'DELETE',\n    });\n  }\n\n  async getFolders(): Promise<Folder[]> {\n    try {\n      const data = await this.makeRequest<{ items: any[] }>('/api/folders');\n      return data.items.map(this.mapFolderFromAPI);\n    } catch (error) {\n      console.error('Failed to fetch folders:', error);\n      return [];\n    }\n  }\n\n  async createFolder(name: string, color?: string): Promise<Folder> {\n    const data = await this.makeRequest<any>('/api/folders', {\n      method: 'POST',\n      body: JSON.stringify({ name, color }),\n    });\n    return this.mapFolderFromAPI(data);\n  }\n\n  async updateFolder(id: string, updates: Partial<Folder>): Promise<Folder> {\n    const data = await this.makeRequest<any>(`/api/folders/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates),\n    });\n    return this.mapFolderFromAPI(data);\n  }\n\n  async deleteFolder(id: string): Promise<void> {\n    await this.makeRequest(`/api/folders/${id}`, {\n      method: 'DELETE',\n    });\n  }\n\n  async getPrompts(): Promise<Prompt[]> {\n    try {\n      const data = await this.makeRequest<{ items: any[] }>('/api/prompts');\n      return data.items.map(this.mapPromptFromAPI);\n    } catch (error) {\n      console.error('Failed to fetch prompts:', error);\n      return [];\n    }\n  }\n\n  async createPrompt(prompt: Omit<Prompt, 'id'>): Promise<Prompt> {\n    const data = await this.makeRequest<any>('/api/prompts', {\n      method: 'POST',\n      body: JSON.stringify(prompt),\n    });\n    return this.mapPromptFromAPI(data);\n  }\n\n  async updatePrompt(id: string, updates: Partial<Prompt>): Promise<Prompt> {\n    const data = await this.makeRequest<any>(`/api/prompts/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates),\n    });\n    return this.mapPromptFromAPI(data);\n  }\n\n  async deletePrompt(id: string): Promise<void> {\n    await this.makeRequest(`/api/prompts/${id}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Mapping functions to convert API responses to our types\n  private mapConversationFromAPI(data: any): Conversation {\n    return {\n      id: data.id,\n      title: data.title || 'Untitled',\n      messages: data.messages?.map(this.mapMessageFromAPI) || [],\n      createdAt: new Date(data.created_at || Date.now()),\n      updatedAt: new Date(data.updated_at || Date.now()),\n      folderId: data.folder_id,\n      isPinned: data.is_pinned || false,\n      tags: data.tags || [],\n    };\n  }\n\n  private mapMessageFromAPI(data: any): any {\n    return {\n      id: data.id,\n      role: data.role,\n      content: data.content,\n      timestamp: new Date(data.timestamp || Date.now()),\n      model: data.model,\n    };\n  }\n\n  private mapFolderFromAPI(data: any): Folder {\n    return {\n      id: data.id,\n      name: data.name,\n      color: data.color,\n      conversationIds: data.conversation_ids || [],\n      createdAt: new Date(data.created_at || Date.now()),\n    };\n  }\n\n  private mapPromptFromAPI(data: any): Prompt {\n    return {\n      id: data.id,\n      title: data.title,\n      content: data.content,\n      category: data.category || 'general',\n      tags: data.tags || [],\n      isFavorite: data.is_favorite || false,\n      usageCount: data.usage_count || 0,\n      createdAt: new Date(data.created_at || Date.now()),\n      updatedAt: new Date(data.updated_at || Date.now()),\n    };\n  }\n}\n\n// Export singleton instance\nexport const apiClient = new ChatGPTAPIClient();","import { stateManager } from '@shared/state';\nimport { apiClient } from '@shared/api';\nimport { storageUtils } from '@shared/utils';\n\nconsole.log('🚀 Ishka Extension Background Script Initialized');\n\n// Initialize extension when installed\nchrome.runtime.onInstalled.addListener(async (details) => {\n  console.log('Extension installed/updated:', details.reason);\n  \n  if (details.reason === 'install') {\n    // Set up initial state\n    await stateManager.resetState();\n    console.log('✅ Initial state set up');\n  }\n  \n  if (details.reason === 'update') {\n    // Handle updates\n    console.log('🔄 Extension updated, checking for data migration...');\n    await handleUpdate();\n  }\n});\n\n// Handle extension startup\nchrome.runtime.onStartup.addListener(async () => {\n  console.log('🔄 Extension starting up...');\n  await initializeExtension();\n});\n\n// Handle messages from content scripts and popup\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  console.log('📨 Received message:', message);\n  \n  handleMessage(message, sender)\n    .then(sendResponse)\n    .catch((error) => {\n      console.error('❌ Error handling message:', error);\n      sendResponse({ error: error.message });\n    });\n  \n  return true; // Keep message channel open for async response\n});\n\n// Handle tab updates\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (changeInfo.status === 'complete' && tab.url?.includes('chatgpt.com')) {\n    console.log('📄 ChatGPT page loaded, injecting content script');\n    injectContentScript(tabId);\n  }\n});\n\n// Handle storage changes\nchrome.storage.onChanged.addListener((changes, namespace) => {\n  console.log('💾 Storage changed:', changes, namespace);\n  \n  // Update state manager with storage changes\n  Object.entries(changes).forEach(([key, change]) => {\n    if (change.newValue !== undefined) {\n      stateManager.setState({ [key]: change.newValue });\n    }\n  });\n});\n\n// Message handler\nasync function handleMessage(message: any, sender: chrome.runtime.MessageSender): Promise<any> {\n  const { type, payload } = message;\n  \n  switch (type) {\n    case 'GET_STATE':\n      return { state: stateManager.getState() };\n      \n    case 'SET_STATE':\n      await stateManager.setState(payload);\n      return { success: true };\n      \n    case 'API_REQUEST':\n      return await handleAPIRequest(payload);\n      \n    case 'GET_STORAGE':\n      return await storageUtils.get(payload.key);\n      \n    case 'SET_STORAGE':\n      await storageUtils.set(payload.key, payload.value);\n      return { success: true };\n      \n    case 'CLEAR_STORAGE':\n      await storageUtils.clear();\n      return { success: true };\n      \n    case 'GET_EXTENSION_INFO':\n      return {\n        version: chrome.runtime.getManifest().version,\n        name: chrome.runtime.getManifest().name,\n        id: chrome.runtime.id,\n      };\n      \n    default:\n      throw new Error(`Unknown message type: ${type}`);\n  }\n}\n\n// API request handler\nasync function handleAPIRequest(payload: any): Promise<any> {\n  const { method, endpoint, data } = payload;\n  \n  try {\n    switch (method) {\n      case 'GET_CONVERSATIONS':\n        return await apiClient.getConversations();\n        \n      case 'GET_CONVERSATION':\n        return await apiClient.getConversation(data.id);\n        \n      case 'CREATE_CONVERSATION':\n        return await apiClient.createConversation(data.title);\n        \n      case 'UPDATE_CONVERSATION':\n        return await apiClient.updateConversation(data.id, data.updates);\n        \n      case 'DELETE_CONVERSATION':\n        await apiClient.deleteConversation(data.id);\n        return { success: true };\n        \n      case 'GET_FOLDERS':\n        return await apiClient.getFolders();\n        \n      case 'CREATE_FOLDER':\n        return await apiClient.createFolder(data.name, data.color);\n        \n      case 'UPDATE_FOLDER':\n        return await apiClient.updateFolder(data.id, data.updates);\n        \n      case 'DELETE_FOLDER':\n        await apiClient.deleteFolder(data.id);\n        return { success: true };\n        \n      case 'GET_PROMPTS':\n        return await apiClient.getPrompts();\n        \n      case 'CREATE_PROMPT':\n        return await apiClient.createPrompt(data.prompt);\n        \n      case 'UPDATE_PROMPT':\n        return await apiClient.updatePrompt(data.id, data.updates);\n        \n      case 'DELETE_PROMPT':\n        await apiClient.deletePrompt(data.id);\n        return { success: true };\n        \n      default:\n        throw new Error(`Unknown API method: ${method}`);\n    }\n  } catch (error) {\n    console.error('API request failed:', error);\n    throw error;\n  }\n}\n\n// Inject content script into tab\nasync function injectContentScript(tabId: number): Promise<void> {\n  try {\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      files: ['content.js'],\n    });\n    console.log('✅ Content script injected');\n  } catch (error) {\n    console.error('❌ Failed to inject content script:', error);\n  }\n}\n\n// Initialize extension\nasync function initializeExtension(): Promise<void> {\n  try {\n    // Load initial data\n    const conversations = await apiClient.getConversations();\n    const folders = await apiClient.getFolders();\n    const prompts = await apiClient.getPrompts();\n    \n    // Update state\n    await stateManager.setState({\n      conversations: {\n        conversations,\n        folders,\n        isLoading: false,\n      },\n    });\n    \n    console.log('✅ Extension initialized successfully');\n  } catch (error) {\n    console.error('❌ Failed to initialize extension:', error);\n  }\n}\n\n// Handle extension updates\nasync function handleUpdate(): Promise<void> {\n  try {\n    // Check for data migration needs\n    const currentVersion = chrome.runtime.getManifest().version;\n    const storedVersion = await storageUtils.get<string>('extension_version');\n    \n    if (storedVersion !== currentVersion) {\n      console.log(`🔄 Migrating from ${storedVersion} to ${currentVersion}`);\n      \n      // Perform any necessary data migrations here\n      \n      // Update stored version\n      await storageUtils.set('extension_version', currentVersion);\n      console.log('✅ Migration completed');\n    }\n  } catch (error) {\n    console.error('❌ Migration failed:', error);\n  }\n}\n\n// Set up periodic tasks\nsetInterval(async () => {\n  try {\n    // Auto-save conversations if enabled\n    const state = stateManager.getState();\n    if (state.user.preferences.autoSave) {\n      const conversations = await apiClient.getConversations();\n      await stateManager.updateConversations({ conversations });\n    }\n  } catch (error) {\n    console.error('❌ Periodic task failed:', error);\n  }\n}, 30000); // Every 30 seconds\n\nconsole.log('✅ Background script setup complete');","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t471: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkishka_extension\"] = self[\"webpackChunkishka_extension\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [804], () => (__webpack_require__(596)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","apiClient","constructor","baseUrl","isAuthenticated","this","checkAuthentication","response","fetch","ok","error","console","warn","makeRequest","endpoint","options","url","defaultOptions","headers","credentials","Error","status","statusText","json","getConversations","items","map","mapConversationFromAPI","getConversation","id","data","createConversation","title","method","body","JSON","stringify","updateConversation","updates","deleteConversation","getFolders","mapFolderFromAPI","createFolder","name","color","updateFolder","deleteFolder","getPrompts","mapPromptFromAPI","createPrompt","prompt","updatePrompt","deletePrompt","messages","mapMessageFromAPI","createdAt","Date","created_at","now","updatedAt","updated_at","folderId","folder_id","isPinned","is_pinned","tags","role","content","timestamp","model","conversationIds","conversation_ids","category","isFavorite","is_favorite","usageCount","usage_count","log","chrome","runtime","onInstalled","addListener","async","details","reason","resetState","currentVersion","getManifest","version","storedVersion","get","set","handleUpdate","onStartup","conversations","folders","setState","isLoading","initializeExtension","onMessage","message","sender","sendResponse","type","payload","state","getState","success","handleAPIRequest","key","value","clear","handleMessage","then","catch","tabs","onUpdated","tabId","changeInfo","tab","includes","scripting","executeScript","target","files","injectContentScript","storage","onChanged","changes","namespace","Object","entries","forEach","change","undefined","newValue","setInterval","user","preferences","autoSave","updateConversations","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","O","result","chunkIds","fn","priority","notFulfilled","Infinity","i","length","fulfilled","j","keys","every","splice","r","d","definition","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","some","chunkLoadingGlobal","self","bind","push","__webpack_exports__"],"sourceRoot":""}